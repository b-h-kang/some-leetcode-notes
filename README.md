## some leetcode notes

#### array approaches:

- Sort
- Two pointer solutions (left and right pointer variables)
- Storing the elements of the array in a HashMap or a Set
- Traversing the array with a sliding window

#### U-questions:

- Are there run time constraints?
- Are there memory constraints?
- Empty input? What to return for empty input?

| num  | problem title                         | approach                                                                                                                   | d   | link                                                                                                                              | fin |
| :--- | :------------------------------------ | -------------------------------------------------------------------------------------------------------------------------- | --- | --------------------------------------------------------------------------------------------------------------------------------- | --- |
| 217  | contains duplicate                    | set => uniqueness                                                                                                          | 🟩  | [here](https://leetcode.com/problems/contains-duplicate/)                                                                         | Y   |
| 1    | 2sum                                  | dict => pool of values contains missing sum                                                                                | 🟩  | [here](https://leetcode.com/problems/two-sum/)                                                                                    | Y   |
| 123  | longest consecutive sequence          | set => if curr += 1 exists, count. NB: curr - 1 not in set for new seq                                                     | 🟨  | [here](https://leetcode.com/problems/longest-consecutive-sequence/)                                                               | Y   |
| 13   | roman to integer                      | dict => dict map, right-to-left pass, subtract if left IV                                                                  | 🟩  | [here](https://leetcode.com/problems/roman-to-integer/)                                                                           | Y   |
| 1436 | destination city                      | set => origin set does not have dest                                                                                       | 🟩  | [here](https://leetcode.com/problems/destination-city/)                                                                           | Y   |
| 20   | valid parentheses                     | stack => push open onto, pop closed                                                                                        | 🟩  | [here](https://leetcode.com/problems/valid-parentheses/)                                                                          | Y   |
| 703  | kth largest el in stream              | heap => maintain heap of size k. then when add, if len>k, pop, ret nums[0]                                                 | 🟩  | [here](https://leetcode.com/problems/kth-largest-element-in-a-stream/)                                                            | Y   |
| 49   | group anagrams                        | hash => k = sorted word, v = defaultdict(list) [eat, tea, ate]                                                             | 🟨  | [here](https://leetcode.com/problems/group-anagrams/)                                                                             | Y   |
| 36   | valid sudoku                          | arr => use array of coords for the 3x3                                                                                     | 🟨  | [here](https://leetcode.com/problems/valid-sudoku/)                                                                               | Y   |
| 125  | valid palindrome                      | two pointer => while left < right, ret True if through                                                                     | 🟩  | [here](https://leetcode.com/problems/valid-palindrome/)                                                                           | Y   |
| 167  | two sum II                            | two pointer => while left < right, if == ret [l+1, r+1]                                                                    | 🟩  | [here](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/submissions/)                                               | Y   |
| 15   | 3sum                                  | two pointer => pA: 0, pB: 1, pC: len(arr)-1, increment pA. NOTE: check total > 0, < 0, then WHILE in == 0 with pB += 1     | 🟨  | [here](https://leetcode.com/problems/3sum/)                                                                                       | Y   |
| 11   | max water container                   | two pointer => if heights[l] > heights[r], r -= 1                                                                          | 🟨  | [here](https://leetcode.com/problems/container-with-most-water/)                                                                  | Y   |
| 42   | trapping rain water                   | two pointer => track maxL and maxR. the smaller one is always guaranteed to hold water so you can total it                 | 🟥  | [here](https://leetcode.com/problems/trapping-rain-water/)                                                                        | Y   |
| 121  | buy and sell stock                    | two pointer => l, r & check ascend ? diff > best : l = r                                                                   | 🟩  | [here](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)                                                            | Y   |
| 3    | longest substring w/o repeat chars    | sliding window => seen set, shift both and rm seen from set                                                                | 🟨  | [here](https://leetcode.com/problems/longest-substring-without-repeating-characters/)                                             | Y   |
| 424  | longest repeating char w/ replacement | sliding window => map { letter : number of occurences }. if windowLen - mostCommon - k ≥ 0 ? shift : expand.               | 🟨  | [here](https://leetcode.com/problems/longest-repeating-character-replacement/)                                                    | Y   |
| 567  | permutation in string                 | sliding window => mapS1 { ltr : # }. mapS2 { a-z : # }. track matches until matches == 26 ? true : false.                  | 🟨  | [here](https://leetcode.com/problems/permutation-in-string/)                                                                      | Y   |
| 76   | minimum window substring              | sliding window => seen { ltr : # }, need { ltr : # }. WHILE seen# = need#: if s[l] in need, l += 1 && seen# -= 1. r += 1   | 🟥  | [here](https://leetcode.com/problems/minimum-window-substring/)                                                                   | Y   |
| 239  | sliding window maximum                | sliding window => use DEQUEUE ???                                                                                          | 🟥  |                                                                                                                                   | TBD |
| 155  | min stack                             | stack => two stacks, regStack && minStack. increment tgt                                                                   | 🟨  | [here](https://leetcode.com/problems/min-stack/)                                                                                  | Y   |
| 150  | evaluate reverse polish notation      | stack => if operand ? eval stack[-2] && stack[-1], pop, then push the res : push letter onto stack. ret stack[0]           | 🟨  | [here](https://leetcode.com/problems/evaluate-reverse-polish-notation/)                                                           | Y   |
| 22   | generate parentheses                  | stack recursion => o == c == n ? add stack to res : o > c ? append ")" : o = c ? append "(". cleanup pop from stack.       | 🟨  | [here](https://leetcode.com/problems/generate-parentheses/)                                                                       | Y-A |
| 739  | daily temperatures                    | monotonic stack => for t in temps: while stack and t > stackTop: pop from stackT and add to res. append each [t, i]        | 🟨  | [here](https://leetcode.com/problems/daily-temperatures/)                                                                         | Y-A |
| 258  | add digits                            | recursion => if < 10 ? ret : for n in num += n, call again                                                                 | 🟩  | [here](https://leetcode.com/problems/add-digits/)                                                                                 | Y   |
| 50   | pow(x, n)                             | recursion => xⁿ = xⁿ'²\* xⁿ'², hence half = pow(x, n//2) once.                                                             | 🟨  | [here](https://leetcode.com/problems/powx-n/)                                                                                     | Y   |
| 334  | reverse string                        | recursion w/ two-pointer => recursive helper to move l, r                                                                  | 🟩  | [here](https://leetcode.com/problems/reverse-string/)                                                                             | Y   |
| 853  | car fleet                             | stack => zipSort. if not stack or (targ - topDist) / topSp < (targ - currDist) / currSp: stack.append(curr) ret len(stack) | 🟨  | [here](https://leetcode.com/problems/car-fleet/)                                                                                  | Y   |
| 84   | largest rectangle in histogram        | stack => while stack && top > curr, pop & find maxArea then append (curr, leftBound if popped). one last pass over rest.   | 🟥  | [here](https://leetcode.com/problems/largest-rectangle-in-histogram/)                                                             | Y-A |
| 704  | binary search                         | two pointer => chop half with m = l + (r-l) // 2 while l ≤ r                                                               | 🟩  | [here](https://leetcode.com/problems/binary-search/)                                                                              | Y   |
| 74   | search 2d matrix                      | binary search => top->bot search ret index then l->r search                                                                | 🟨  | [here](https://leetcode.com/problems/search-a-2d-matrix/)                                                                         | Y   |
| 875  | koko eating bananas                   | binary search => 1->max(piles), track minK. forech p, tot += ceil(p/m). if tot ≤ h, min(minK, tot) l = m+1 else r = m-1    | 🟨  | [here](https://leetcode.com/problems/koko-eating-bananas/)                                                                        | Y   |
| 153  | min rotated sorted arr                | binary search => track min, check m. m > r ? l = m+1 : r = m-1. at end, minVal = min(nums[l],minVal) to check any last one | 🟨  | [here](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)                                                       | Y   |
| 33   | search in rotated sorted array        | binary search => find min, then set minIndx to negative & find                                                             | 🟨  | [here](https://leetcode.com/problems/search-in-rotated-sorted-array/)                                                             | Y   |
| 981  | key-value time store                  | binary search => TBD                                                                                                       | 🟨  | [here](https://leetcode.com/problems/time-based-key-value-store/)                                                                 | TBD |
| 206  | reverse linked list                   | 2P => init prev = None, ret prev, repoint curr to prev                                                                     | 🟩  | [here](https://leetcode.com/problems/reverse-linked-list/)                                                                        | Y-A |
| 21   | merge two sorted LLs                  | LL => use dummy & curr, compare l1, l2. once None add rest                                                                 | 🟩  | [here](https://leetcode.com/problems/merge-two-sorted-lists/)                                                                     | Y   |
| 143  | reorder list                          | two pointer LL => find mid, reverse 2nd half, merge 1st & 2nd                                                              | 🟨  | [here](https://leetcode.com/problems/reorder-list/)                                                                               | Y   |
| 19   | remove nth node from end of list      | 2P LL => set f=head,s=dummy & move f until gap of n, inc f,s until f is at end, then jump s.next to s.next.next            | 🟨  | [here](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)                                                           | Y   |
| 138  | copy list with random pointer         | LL => make reg deepcopy, populate map with { head : copy }, then traverse both, repoint random field to map[head] = copy   | 🟨  | [here](https://leetcode.com/problems/copy-list-with-random-pointer/)                                                              | Y   |
| 2    | add two numbers                       | LL => O(m+n) conv to str. O(max(m,n)) while l1 or l2 or carry                                                              | 🟨  | [here](https://leetcode.com/u/bhkang/)                                                                                            | Y   |
| 141  | LL cycle detection                    | LL => tortoise and hare algo. hare always takes n-1 to catch.                                                              | 🟩  | [here](https://leetcode.com/problems/linked-list-cycle/)                                                                          | Y   |
| 287  | find the duplicate number             | Floyd's LL => find 1st f == s with floyd. init s2 = 0 and increment s until s == s2. this is the cycle (and thus dupe)     | 🟨  | [here](https://leetcode.com/problems/find-the-duplicate-number/)                                                                  | Y-M |
| 146  | LRU cache                             | hashMap + DLL => map { k : Node(k,v) }. LRU<->Node<->MRU.                                                                  | 🟨  | [here](https://leetcode.com/problems/lru-cache/)                                                                                  | Y-A |
| 226  | invert binary tree                    | tree rec => if not root ret, else switch children. recur call                                                              | 🟩  | [here](https://leetcode.com/problems/invert-binary-tree/solution/)                                                                | Y-M |
| 104  | maximum depth of a binary tree        | rec => use rec DFS, queue iter BFS, stack iter preorder DFS                                                                | 🟩  | [here](https://leetcode.com/problems/maximum-depth-of-binary-tree/)                                                               | Y-A |
| 543  | binary tree diameter                  | rec DFS => global maxLen, check l+r, then ret 1 + max(l, r)                                                                | 🟩  | [here](https://leetcode.com/problems/diameter-of-binary-tree/)                                                                    | Y-A |
| 110  | balanced binary tree                  | rec DFS => normal dfs but check abs(l-r)>1 ? False : True                                                                  | 🟩  | [here](https://leetcode.com/problems/balanced-binary-tree/)                                                                       | Y   |
| 100  | same binary tree                      | rec => 3 base cases, else isSame(p.r,q.r) && isSame(p.l,q.l)                                                               | 🟩  | [here](https://leetcode.com/problems/same-tree/)                                                                                  | Y   |
| 572  | subtree of bin. tree                  | DFS rec => isSub to travse, sameTree to check if identical                                                                 | 🟩  | [here](https://leetcode.com/problems/subtree-of-another-tree/)                                                                    | Y   |
| 235  | lowest common ancestor of a BST       | BST => travse based on p,q > root or less. once this is not true we have found the lowest common ancestor                  | 🟨  | [here](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/submissions/)                                 | Y   |
| 102  | binary tree level order traversal     | BFS iter => queue BFS, w/ append to sublist in each forloop                                                                | 🟨  | [here](https://leetcode.com/problems/binary-tree-level-order-traversal/)                                                          | Y   |
| 199  | binary tree right side view           | BFS iter => level order traversal. append to retList the last val in each level and return. use var to track len(q)        | 🟨  | [here](https://leetcode.com/problems/binary-tree-right-side-view/)                                                                | Y   |
| 1448 | count good nodes in binary tree       | DFS rec => preorder, dfs(node, maxInt). if node.val ≥ maxInt, increment and reassign maxInt, then cont until the end       | 🟨  | [here](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)                                                            | Y   |
| 98   | validate BST                          | DFS rec => check and update possible bounds for each node                                                                  | 🟨  | [here](https://leetcode.com/problems/validate-binary-search-tree/)                                                                | Y   |
| 230  | kth smallest in BST                   | DFS rec/iter => inordr travse. iter: curr = curr.right at end                                                              | 🟨  | [here](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)                                                              | Y-A |
| 105  | bintree w/preorder & postorder travse | DFS rec => root = Node(pre[0]). split pre & inord based on inord.index(pre[0]). root.l = recLeft, root.r = recRight        | 🟨  | [here](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)                                  | Y-A |
| 78   | subsets                               | DFS bcktrk => decision tree at each nums[i]. one dfs with, one dfs w/o                                                     | 🟨  | [here](https://leetcode.com/problems/subsets/)                                                                                    | Y   |
| 39   | combination sum                       | DFS bcktrk => dec.tree at each nums[i] w/ repetition. 1 dfs w, 1 dfs w/o                                                   | 🟨  | [here](https://leetcode.com/problems/combination-sum/)                                                                            | Y   |
| 46   | permutations (my way)                 | DFS rec => dec.tree with pass down set with nums yet to visit in comb                                                      | 🟨  | [here](https://leetcode.com/problems/permutations/)                                                                               | Y-B |
| 90   | subsets ii                            | DFS bcktrk => subsets but with while to skip dupes ON backtrack                                                            | 🟨  | [here](https://leetcode.com/problems/subsets-ii/)                                                                                 | Y-M |
| 40   | combination sum ii                    | DFS bcktrk => dectree comb sum i w/bcktrk while skip dupes. BASE CASE ISSUE                                                | 🟨  | [here](https://leetcode.com/problems/combination-sum-ii/)                                                                         | Y-M |
| 79   | word search                           | DFS bcktrk => two base cases, else dfs(4dirs). add to path & clean up after                                                | 🟨  | [here](https://leetcode.com/problems/word-search/)                                                                                | Y-M |
| 131  | palindrome partitioning               | DFS bcktrk => given aab, a->a->b (pl), ->ab (nPal); aa->b (pl); aab (nPal)                                                 | 🟨  | [here](https://leetcode.com/problems/palindrome-partitioning/)                                                                    | Y-M |
| 17   | letter combinations of a phone number | DFS bcktrk => standard dectree with backtracking pop to cleanup                                                            | 🟨  | [here](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)                                                      | Y   |
| 271  | encode decode string                  | arr => use len#word format -> 4#neet3#lov. note wordLen can be 2+ digits                                                   | 🟨  | [here](https://leetcode.com/problems/encode-and-decode-strings/)                                                                  | Y   |
| 1046 | last stone weight                     | heap => max heap. keep crushing while len(heap) > 1. ret -heap[0]                                                          | 🟩  | [here](https://leetcode.com/problems/last-stone-weight/)                                                                          | Y   |
| 973  | k closet points to origin             | heap => max heap. o(logk) to add/pop when len > k. bundle coord in tuple.                                                  | 🟨  | [here](https://leetcode.com/problems/k-closest-points-to-origin/submissions/)                                                     | Y   |
| 215  | kth largest elem in array             | heap [Y] / quickselect [N] => normal minheap w/ k size. quickselect TODO.                                                  | 🟨  | [here](https://leetcode.com/problems/kth-largest-element-in-an-array/https://neetcode.io/problems/kth-largest-element-in-an-arra) | Y-B |
| 621  | task scheduler                        | heap/q => n=3,max[-3,-1,-1],q[[3A, 4ind],[1B, 3ind]]. if not heap jump.                                                    | 🟨  | [here](https://leetcode.com/problems/task-scheduler/)                                                                             | Y-A |
| 23   | merge k sorted lists                  | heap/ll => ptr at each LL. bundle (val,ptr) in minHeap, pop til heap empty                                                 | 🟥  | [here](https://leetcode.com/problems/merge-k-sorted-lists/)                                                                       | Y   |
| 355  | design twitter                        | heap/hash => follows{user:set(flwers)}, posts{user:[[time,postId]]}. foreach follower, add to heap [time,postId,user,indx] | 🟨  | [here](https://leetcode.com/problems/design-twitter/)                                                                             | Y   |
| 200  | number of islands                     | dfs/bfs mtrx => standard matrix search. practice with rec dfs, iter dfs/bfs                                                | 🟨  | [here](https://leetcode.com/problems/number-of-islands/)                                                                          | Y   |
| 695  | max area of islands                   | dfs/bfs mtrx => standard matrix search. practice with rec dfs, iter dfs/bfs                                                | 🟨  | [here](https://leetcode.com/problems/max-area-of-island/)                                                                         | Y-B |
| 133  | clone graph                           | dfs => copy.neighbrs .append(dfs(neighbor)). return copy at end. TODO again                                                | 🟨  | [here](https://leetcode.com/problems/clone-graph/)                                                                                | Y-M |
| 286  | walls and gates                       | bfs mtrx => simultaneous bfs on all 0s by add to q. if already visited, stop                                               | 🟨  | [here](https://leetcode.com/problems/walls-and-gates/)                                                                            | Y-A |
| 994  | rotting oranges                       | bfs mtrx => keep count of fresh. while q AND fresh > 0 & dec fresh, inc time                                               | 🟨  | [here](https://leetcode.com/problems/rotting-oranges/)                                                                            | Y-M |
| 417  | pacific atlantic water flow           | dfs/bfs mtrx => separate dfs for pac & atl. pass in visited set & prevHeigt. start from edges & go in if still good        | 🟨  | [here](https://leetcode.com/problems/pacific-atlantic-water-flow/)                                                                | Y-M |
| 207  | course schedule                       | dfs adj list => { cour : set(re) }. track seen w/set. rm req from set rec                                                  | 🟨  | [here](https://leetcode.com/problems/course-schedule/)                                                                            | Y-M |
| 130  | surrounded regions                    | dfs/bfs mtrx => all edge Os are Bs. then replace remaining Os, swap Bs back.                                               | 🟨  | [here](https://leetcode.com/problems/surrounded-regions/)                                                                         | Y   |
|      |                                       |                                                                                                                            |     |                                                                                                                                   |     |
